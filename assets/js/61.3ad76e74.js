(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{544:function(t,s,e){"use strict";e.r(s);var a=e(4),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("介绍")]),t._v(" "),e("p",[t._v("inspect生产环境动态开启"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"前提"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前提"}},[t._v("#")]),t._v(" 前提")]),t._v(" "),e("p",[t._v("nodejs在本地调试时主要通过添加一个inspect，此时一切表现正常，但在生产环境中没法这么轻松")]),t._v(" "),e("blockquote",[e("p",[t._v("当然可以直接远程连接机器，直接在命令行去操作，但在一些安全策略下，我可能没有权限这样做，再加上我对linux不熟悉，我尽量避免使用这个方法，而是使用标准的用chrome连接的方法")])]),t._v(" "),e("h2",{attrs:{id:"分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[t._v("#")]),t._v(" 分析")]),t._v(" "),e("p",[t._v("如果用chrome调试的话，生产环境会出现三个比较大的问题，一个是cluster带来的多进程屏蔽，一个是框架封装度高导致内部不透明，一个是调试的端口通过去何种方法去通知给用户")]),t._v(" "),e("h2",{attrs:{id:"解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[t._v("#")]),t._v(" 解决")]),t._v(" "),e("p",[t._v("一个一个来吧")]),t._v(" "),e("p",[t._v("一:我想要连接到指定进程进行调试，发出的请求到服务器的时候，是cluster中的master负责接收，并把这个请求在负载均衡的前提下交给一个子进程")]),t._v(" "),e("p",[t._v("问题出现了:我没有办法保证是指定的子进程接收到，我每次调试的进程大概率是随机的(当请求较少时，就是一个固定的请求接收，而这个进程同样大概率不是我想要的")]),t._v(" "),e("p",[t._v("二我想连接一个进程，我至少要知道这个进程叫什么名字，也就是在cluster分裂子进程的时候，需要记录子进程的pid，如果多进程的部分是自己写的话，问题不大，但实际上往往是采用类似pm2的东西，也就是我必须深入一个封装东西的内部去记录，并且在以后不用pm2换成别的时候，重新做一次这样的操作")]),t._v(" "),e("p",[t._v("三 主要是依赖inspector去动态打开调试功能(而不是一直打开)，那么这个生成的websocket连接端口，要么因为集群内部的原因，要么因为安全策略的原因，无法被外部连接，该怎么办？")]),t._v(" "),e("p",[t._v("解决思路:通过原生的方法，记录pid，生成一个agent进程，这个进程啥都不做就负责管理子进程pid及ws连接，每个子进程生成时通过ipc命名管道通知agent。想要调试的时候直接来找agent进程，agent再通知具体进程开放调试端口，agent再通过一个代理的模式，让外部连接到")]),t._v(" "),e("p",[t._v("未完，线程级别也可以调试，但不能用net模块ipc这个思路了，要通过线程级别的消息通知来做")])])}),[],!1,null,null,null);s.default=r.exports}}]);