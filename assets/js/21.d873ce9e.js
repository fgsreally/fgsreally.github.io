(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{505:function(e,s,t){"use strict";t.r(s);var v=t(4),a=Object(v.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("介绍")]),e._v(" "),t("p",[e._v("babel，webpack，vite原理+工程化的一些主体方法"),t("br")])]),e._v(" "),t("h3",{attrs:{id:"工程化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工程化"}},[e._v("#")]),e._v(" 工程化")]),e._v(" "),t("p",[e._v("我肯定还是偏向去做这一类的，人生什么事情都应该效率拉满。这里我计划把babel，webpack，vite,这些东西写一下，工程化的一些主体方法写一下")]),e._v(" "),t("h2",{attrs:{id:"第一步-工程化的入口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一步-工程化的入口"}},[e._v("#")]),e._v(" 第一步，工程化的入口")]),e._v(" "),t("p",[e._v("所谓入口并不是指index.js这种东西，而是指使用工具时的入口。这种入口主体上有三种")]),e._v(" "),t("ul",[t("li",[e._v("命令行式，这种不多说了，算是相当常见了")]),e._v(" "),t("li",[e._v("Inquirer，就是那个vuecli，中选择版本的那个")]),e._v(" "),t("li",[e._v("图形化，那个cypress（就是那个e2e测试的，我可能拼写错了）")])]),e._v(" "),t("p",[e._v("其实我个人比较喜欢第三种，因为第二种如果情况比较多的话，inquirer要搞好多逻辑，第一种没啥坏处，就是你长期不用了回来可能忘掉了...第三种主要是会体积大一点，就按个标准前端的东西去写")]),e._v(" "),t("h2",{attrs:{id:"第二步-一些基本的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二步-一些基本的方法"}},[e._v("#")]),e._v(" 第二步，一些基本的方法")]),e._v(" "),t("p",[e._v("包括shell.exec（执行命令行的东西）,文件读取，正则，模板引擎")]),e._v(" "),t("p",[e._v("我想了想这些东西有啥可说的呢，好像也没啥可说的，真没啥，就是些简单的东西，唯一的建议就是能用第二步解决的，就第二步解决。我那个脚手架就是简单的文件读写加模板引擎，除了看着low了点，其他都挺好")]),e._v(" "),t("h2",{attrs:{id:"第三步-ast语法树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三步-ast语法树"}},[e._v("#")]),e._v(" 第三步，ast语法树")]),e._v(" "),t("p",[e._v("我很难评价...这个东西其实非常好用，因为它能够去真正’解析‘JS，\n以Babel为例：\n目的是将es6转为es5（当然还有其他目的\n（附：工程化里面很常见的一环就是，利用"),t("strong",[e._v("替换")]),e._v("，将浏览器不认识的部分转化为认识的）")]),e._v(" "),t("p",[e._v("一共是三步")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("构建ast语法树，这个用啥方法都行，我当时手写用的是acorn，但你用Babel的parser也行，注意一下各个节点的类型，如果觉得哪个类型写法自己不喜欢，趁这个parser阶段赶紧改了")])]),e._v(" "),t("li",[t("p",[e._v("遍历语法树，我一直觉得前端不用学算法的，到这里我着实犹豫了，不过这个并不是那些二叉树算法，就是一个简单遍历递归的东西，没有任何难度，关键是在遍历过程中，对各个节点进行修改（其实我从来没有做过相关的东西，因为我不知道要转化成啥...)")])]),e._v(" "),t("li",[t("p",[e._v("将语法树重新拼接成js语句，并且写入文件，我不太记得了，好像是遍历了一遍树，根据节点类型进行拼凑就行了")])])]),e._v(" "),t("h3",{attrs:{id:"webpack原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack原理"}},[e._v("#")]),e._v(" Webpack原理")]),e._v(" "),t("p",[e._v("webpack的基础原理差不多，从入口文件进去生成语法树，遍历里面的依赖，也就是把里面的import from 一层层的找出来，最后生成js语句，以立即执行函数的形式写进出口文件")]),e._v(" "),t("p",[e._v("我前两天瞄了一眼一些面试题，发现喜欢问loader和plugin，所以就这里记一下")]),e._v(" "),t("blockquote",[t("p",[e._v("实际上我从来没用过...现成脚手架挺好用的啊..")])]),e._v(" "),t("p",[e._v("loader其实就是一个node的中间件，把读到的文件内容（字符串形式），过一下中间件，然后返回,所以loader就是个函数，有个返回值，功能就是转化，所以有啥css-loader，less-loader...")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("plugin可就太神奇了，它是一个类的形式，里面有个apply方法，在配置文件中实例化。它的作用就是在特定的钩子处做事，这里按照文档，决定钩子类型和是否异步，进入的东西是compiler （在里面也可以得到complition,前者是不会变的，后者是会随着阶段改变而改变的）")]),e._v(" "),t("p",[e._v("和loader的区别是，执行的时间可以自己决定，执行的对象是一个compiler对象（"),t("strong",[e._v("js对象")]),e._v("）而非一个字符串，如果要写plugin，最好先输出一下compiler的各个属性看一下都是些啥，要对哪些做处理，是要对依赖处理还是别的什么\n我那个脚手架（虽然不太算前端就是了）是图形界面传给后端一个js对象，然后根据对象中的各个值，传入模板引擎。\n像这种js对象每个属性都用上的情况不多见，实际上这个脚手架我每次都提醒自己还有哪个哪个地方没做，然后一打开项目，代码一大坨一大坨的，根本改不动...\n还是怪我自己没管理好")]),e._v(" "),t("h2",{attrs:{id:"vite的bundless-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vite的bundless-原理"}},[e._v("#")]),e._v(" vite的bundless 原理")]),e._v(" "),t("p",[e._v("vite的话，我不太清楚它是怎么打包的，因为我没有build过一个vite项目，我只知道是rollup的打包\n开发过程中的无打包，也就是bundless,就是写了个服务器，对应端口返回一个html，html中有一个入口js，当浏览器申请这个js文件时，服务器先把这个js文件中的import from 部分替换成一个新的script 标签，浏览器就会再发请求去找这个依赖的js文件")]),e._v(" "),t("p",[e._v("需要注意的是，如果是node_module里的文件，需要更改一下对应的路径让服务器找的到，如果import 里面不是js文件，要先解析，比如.vue 文件要先解析（我记得vue3的哪个版本以后就没有sfc的解析了，所以我到那一步就卡住了，后来我打算用vue.extend将.vue文件内容生成一个组件实例，一个js对象，再发回去，不过我没试用，就只是写了那个转化的组件用在低代码平台了。")]),e._v(" "),t("p",[e._v("vite里面的插件和webpack差不太多，好像就是rollup的钩子加了点专属的钩子，这个我没啥印象了")])])}),[],!1,null,null,null);s.default=a.exports}}]);