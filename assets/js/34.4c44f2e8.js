(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{518:function(t,s,a){"use strict";a.r(s);var n=a(4),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("介绍")]),t._v(" "),a("p",[t._v("node中的错误类型，错误抓取，错误处理等"),a("br")])]),t._v(" "),a("h2",{attrs:{id:"node中一些基本的错误处理知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node中一些基本的错误处理知识"}},[t._v("#")]),t._v(" node中一些基本的错误处理知识")]),t._v(" "),a("blockquote",[a("p",[t._v("首先，程序员失误写错的代码，这个是属于不能容忍其存在的，是要直接消灭掉而不是等它错误了再做对应的处理，我这里说的错误都不是指这种\n错误抓取基本就这么几种")])]),t._v(" "),a("ul",[a("li",[t._v("try-out 同步")]),t._v(" "),a("li",[t._v("回调 当然写成promise也没啥区别")]),t._v(" "),a("li",[t._v("event.on('error') 也就是事件的思路\n当然如果整个程序中只有一两个地方有概率犯错，那用上面这几个就差不多够了，但当程序够大，任何地方都有概率出异常时，你就需要一些意识层面的东西了")])]),t._v(" "),a("h2",{attrs:{id:"将错误分类处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将错误分类处理"}},[t._v("#")]),t._v(" 将错误分类处理")]),t._v(" "),a("ul",[a("li",[t._v("express的错误处理中间件，某一条链路的路由由一个错误中间件管")]),t._v(" "),a("li",[t._v("domain，为了解耦而解耦，结果越搞越复杂。。现在已经被放弃了\n这两种就是，不同地方的错误，不同处理，或者说，有很多个小管理者分布在整个程序里")])]),t._v(" "),a("blockquote",[a("p",[t._v("最起码能锁定错误大概的位置...")])]),t._v(" "),a("h2",{attrs:{id:"走投无路-jpg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#走投无路-jpg"}},[t._v("#")]),t._v(" 走投无路.jpg")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v(" process"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'uncaughtException'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//监听未捕获的异常")]),t._v("\n \n process"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'unhandledRejection'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//监听Promise没有被捕获的失败函数")]),t._v("\n")])])]),a("p",[t._v("如果看过express generator生成出来的项目，在www里面，能看到上面的东西，说白了，出现完全没想到的错误，或者错误出现在完全没想到的地方时，至少要让程序接着跑下去")]),t._v(" "),a("blockquote",[a("p",[t._v("这个时候已经不是错误‘处理’了，往往也没机会处理了，一般在回调中都是直接重启程序（守护进程，如node-forever）")])]),t._v(" "),a("h3",{attrs:{id:"进阶知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进阶知识"}},[t._v("#")]),t._v(" 进阶知识")]),t._v(" "),a("p",[t._v("node 中的错误类型")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("Error："),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//通用的错误类型，例如：new Error('error!!!')。")]),t._v("\nSyntaxError："),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//语法错误，例如：require('vm').runInThisContext('binary ! isNotOk')。")]),t._v("\nReferenceError："),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//引用错误，如引用一个未定义的变量，例如：doesNotExist。")]),t._v("\nTypeError："),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//类型错误，例如：require('url').parse(() => {})。")]),t._v("\nURIError："),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//全局的 URI 处理函数抛出的错误，例如：encodeURI('\\uD800')。")]),t._v("\nAssertError："),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用 assert 模块时抛出的错误，例如：assert(false)")]),t._v("\n")])])]),a("p",[t._v("实际上错误处理中最重要的一环是，对出什么类的错要心里大概有数...如果做不到，最起码要知道，错误在哪里，或者说，定位错误。\n定位错误本身并不是一件容易的事情，比如，有一个函数A，在第10行，有多个地方调用这个函数A，假设其中有一个出现异常，那么最后显示异常的位置就是第10行，这对我们定位是没有任何帮助的")]),t._v(" "),a("h2",{attrs:{id:"错误栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误栈"}},[t._v("#")]),t._v(" 错误栈")]),t._v(" "),a("p",[t._v("在上面的例子中，A函数的栈，假设是X1,那么报错的第一位置肯定是x1，我希望定位这个A函数执行的位置的栈，也就是x2，也就是希望能显示报错的第二位置是x2，我只需要看第二位置就可以定位错误\n对于执行栈的一些操作，可以考虑使用v8的api")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("Error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("captureStackTrace")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("targetObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" constructorOpt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Error.captureStackTrace 会在 targetObject 中添加一个 stack 属性，对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息（即：调用栈历史）")]),t._v("\nError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("prepareStackTrace")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" structuredStackTrace"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定制stack")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("其实也没啥用。。")])]),t._v(" "),a("h2",{attrs:{id:"async-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-hooks"}},[t._v("#")]),t._v(" async hooks")]),t._v(" "),a("p",[t._v("这个东西是个很神奇的东西，从8.0到16，一直是试验版本，没有淘汰没有稳定化...而且里面把console.log算成了异步操作...\n其功能是跟踪所有的异步操作，其神奇之处就是，异步操作往往是上下文变化，也就是执行环境都在变，所以asynchooks是可以跟踪执行上下文的！")]),t._v(" "),a("blockquote",[a("p",[t._v("上下文切换往往都能产生麻烦，尤其是性能方面，最出名的就是所谓dom操作消耗资源（其实本质是在js上下文和dom上下文切换中消耗的），所以asynchooks不是上生产环境的\n那么能做的操作就多了，我曾经写了一个全链路跟踪，去跟踪程序中的微服务（因为微服务发生在其他地方，其内部是屏蔽的，如果出异常可能意识不到是在微服务环节的，亦或者程序太大，各种东西都在调用微服务，最后根本不记得谁调用了谁，这个时候可以跟踪一下看看。去跟踪微服务以外的东西其实也行，这个感觉有点像webpack插件hh）\n还可以去计算各个异步操作的耗时（我正打算往跟踪项目里面加一个这个部分，除此之外，我还打算让程序能显示此时执行方法的名称，而不是默认的数字（asynchooks会给各个函数一个独有的数字当标记），但看mdn那个arguments.callee好像不太靠谱...")])])])}),[],!1,null,null,null);s.default=r.exports}}]);