(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{532:function(v,_,t){"use strict";t.r(_);var a=t(4),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"后端表到前端表单的极速-crud"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端表到前端表单的极速-crud"}},[v._v("#")]),v._v(" 后端表到前端表单的极速 crud")]),v._v(" "),t("p",[v._v("我之前写过一个可视化的脚手架，去快速生成 crud，效果呢，感觉却并不是很好,使用效果差主要来自于两方面")]),v._v(" "),t("ol",[t("li",[v._v("当需求不那么简单，也就是存在联表管道分页这些")]),v._v(" "),t("li",[v._v("存在比较多的副逻辑，比如鉴权，类型限制这些")])]),v._v(" "),t("p",[v._v("在 nodejs 里面的话，前者如果不涉及过多表的话并不困难，像 mongodb 的话更是特别容易，后者可以是放在中间件，亦或者各类装饰器里，在模板里面很容易处理。")]),v._v(" "),t("p",[v._v("但麻烦的是生成接口以后的部分，也就是，我需要的并不仅仅是一个可以用的接口，既然意图是要快速地 crud，那么最好生成的代码或者项目是整个流程的所有部分，而非仅仅接口部分")]),v._v(" "),t("p",[v._v("换而言之，一个简单的后台系统大概是这么几个部分")]),v._v(" "),t("ol",[t("li",[v._v("定义表结构")]),v._v(" "),t("li",[v._v("接口逻辑部分，即调用数据库存取")]),v._v(" "),t("li",[v._v("副逻辑")]),v._v(" "),t("li",[v._v("文档")]),v._v(" "),t("li",[v._v("前端，包括表的展示，和操作页面，副页面(登陆页面等")])]),v._v(" "),t("p",[v._v("那么，在需求不那么复杂的时候，只有 1 这个部分是无法避免的，其他部分均有重复之前步骤或本身比较简单，常见")]),v._v(" "),t("p",[v._v("那么我希望的就是，在第一步以后，直接生成后续部分的代码，并且当特殊需求时，能很方便地在其中更改\n(并不是完全自动化，只是尽可能去省一些部分，技术栈上，是 nestjs 加 vue")]),v._v(" "),t("h1",{attrs:{id:"具体流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体流程"}},[v._v("#")]),v._v(" 具体流程")]),v._v(" "),t("ol",[t("li",[v._v("通过 ast 分析，确认表中对象，去生成一个中间结构。\n这样说有点模糊了，举个例子，一个实体中存在一个 id，一个 username，一个 password，一个枚举类型的 class(所属班级，那么映射到前端，大概率这个 id 不在前端，username 对应一个 input，密码对应一个带隐匿的 input，class 对应一个 select")])]),v._v(" "),t("p",[v._v("也就是说，要对这个中间对象进行一步步的处理，直到前端的 ui 表现，因为用的是 nestjs 和 avue，那么就是这个中间对象一步一步到 avue crud 的配置项，过程中还要尽可能生成 ts 类型，用于 validate pipe")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("生成接口部分，这一部分比较死板，只有一些类型的不同(副逻辑部分不在这里生成！或者说，整个流程都是不生成副逻辑，包括后面的副页面的，即使生成也是全局统一配置(比如 swagger 的东西")])]),v._v(" "),t("p",[v._v("(主要是副的东西插入进去不复杂，通过装饰器可以直接写在函数外，如果是个耦合比较重，不太好插入的东西，就不要这么做，应在模板内部生成)")]),v._v(" "),t("p",[v._v("注意，这里也有麻烦的部分，比如操作实体需要注入属性，那么如果涉及多个实体，注入的种类数量都有变化")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[v._v("生成各种类型，包括 swagger 的 req.res 类型，入参，也就是管道的类型")])]),v._v(" "),t("li",[t("p",[v._v("生成前端部分，这个部分非常简单，除去环境产量以外基本是写死的，页面路由信息是通过后端接口动态生成，crud 的配置也是来源于后端，举个例子，我进入学生的管理页，那么就会向/student/options 接口发请求，得到配置项渲染页面")])])]),v._v(" "),t("p",[v._v("也就是后端除去 crud 接口，还要有一个配置项接口")]),v._v(" "),t("p",[v._v("总结")]),v._v(" "),t("ol",[t("li",[v._v("实体/表结构")]),v._v(" "),t("li",[v._v("类型")]),v._v(" "),t("li",[v._v("固定接口(固定")]),v._v(" "),t("li",[v._v("controller 的注入")]),v._v(" "),t("li",[v._v("配置接口")]),v._v(" "),t("li",[v._v("前端部分(固定")])]),v._v(" "),t("h1",{attrs:{id:"麻烦之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#麻烦之处"}},[v._v("#")]),v._v(" 麻烦之处")]),v._v(" "),t("p",[v._v("前端的 crud 部分我个人开发工作量太大，就借用了 avue，这样一来，后端接口标准也就被限制了，而且配置项也是它的标准，中间对象转过去很难，因为配置项有很多 ui 的东西是不可能自动生成的")]),v._v(" "),t("p",[v._v("其次，现在的 nest 的 crud 装饰器，一些现成的库，内部都是封装死的，连往单个接口加装饰器都做不到，所以后端还是要自己处理全部的模板。")]),v._v(" "),t("p",[v._v("除此之外，类型生成，以及数据库选择都比较麻烦，(因为这样装饰器名就变了")]),v._v(" "),t("h1",{attrs:{id:"现状"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#现状"}},[v._v("#")]),v._v(" 现状")]),v._v(" "),t("p",[v._v("有两个版本，一个是用 ast 做的，也就是按照上面这个，第二个用 es_lexer 那个做的，更快更容易，主要就是 4 可以做的更轻松，但类型的部分无法处理，而且配置接口也要自己做，即 2，5 两部分不能做，2 部分没办法，5 部分可以通过 avue 官方的 crud 表格生成器去生成配置项，还算的上容易")]),v._v(" "),t("h1",{attrs:{id:"目标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目标"}},[v._v("#")]),v._v(" 目标:")]),v._v(" "),t("p",[v._v("swagger 那里的话，可以用 example 加上类型。想想办法能不能用实体直接生成 example，就是 fake data 那一套")])])}),[],!1,null,null,null);_.default=s.exports}}]);