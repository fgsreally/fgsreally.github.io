(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{531:function(t,e,n){"use strict";n.r(e);var s=n(4),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"依赖注入与控制反转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入与控制反转"}},[t._v("#")]),t._v(" 依赖注入与控制反转")]),t._v(" "),n("p",[t._v("首先呢，使用 nestjs 的话懂不懂这两个影响不大，还是看业务的量级，量级大结构做的复杂，引用的模块功能和配置都不好懂，用起来就难，业务简单模块少自然用起来就轻松。\n在说这个原理之前，我先说一个 three 的项目\n假设有一个世界类，一个房子类，在创建世界的时候，有一个步骤就是创建房子，创建房子的时候，又需要光照等世界里面的属性")]),t._v(" "),n("p",[t._v("既然房子需要世界的属性，那当然希望继承它，但一个世界不可能只有一个房子，还有人啊车啊，如果每个都继承世界类，那么 new 了房子人车，至少创建了三个世界(或许不会出问题，但一定浪费空间性能)，但实际上这些东西都是共用一个世界的\n其次，无论继承与否，新的类接受属性时的过程是重复且容易犯错的，比如命名冲突或者遗漏属性\n那么从工程化的角度讲，需要做 1，单例化，2，属性注入，而且这两个行为都是比较死的，可以重用的，也就是说这两个部分应该尽可能不通过手写，要么自动生成，要么内置功能")]),t._v(" "),n("p",[t._v("nestjs 中的体现就是，类的实例化是框架去做的，而不是自己 new，然后框架来确保实例的唯一，这就是控制反转，框架而不是开发者来控制，当某个实例中需要其他实例的功能时，只需要声明要什么功能，框架会自动引入，然后通过更多的类型帮助防止冲突，这就是依赖注入")]),t._v(" "),n("p",[t._v("可以同样在 three 中做一个类似的东西，myroom3d 里面就有一个简单的实现")])])}),[],!1,null,null,null);e.default=r.exports}}]);