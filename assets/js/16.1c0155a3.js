(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{502:function(s,e,t){"use strict";t.r(e);var r=t(4),a=Object(r.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("介绍")]),s._v(" "),t("p",[s._v("以nest和express为主，总结各种web框架思路"),t("br")])]),s._v(" "),t("h3",{attrs:{id:"我写过的一个web框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我写过的一个web框架"}},[s._v("#")]),s._v(" 我写过的一个web框架")]),s._v(" "),t("p",[s._v("我曾自己写过一个node的web框架，就是中间件那一套，当时我嫌弃别的框架中间件只能是队列式，一个接一个的，太过呆板，所以我就做了个贼复杂的图式的，就根据不同的条件进入不同的分支...")]),s._v(" "),t("p",[s._v("用起来连我这个设计者都晕。")]),s._v(" "),t("blockquote",[t("p",[s._v("我想说的是，无论是web框架的设计还是选择，都要首先考虑易用性")])]),s._v(" "),t("h2",{attrs:{id:"各类框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#各类框架"}},[s._v("#")]),s._v(" 各类框架")]),s._v(" "),t("p",[s._v("其实node框架会一两个差不多就够用了，express.koa的源码也没有那么复杂，大概看看原理就行，实际上除去这两个经典且简单的框架，其他框架都是在两个方向做突破(但本质上都不能突破这两个框架，所以可以看到很多框架都是明说自己基于express/koa")]),s._v(" "),t("ol",[t("li",[s._v("企业级应用，说白了就是把结构定死，express框架，就算express脚手架生成的项目逻辑已经很清晰了，但不同的人一上手还是能写的奇奇怪怪，最后至于无法管理和更改")])]),s._v(" "),t("p",[s._v("所谓企业级，最标志的就是把一些规定定死，这种情况下你写出来的和我写出来的结构不至于差别太大,以nest为例，虽然说依赖注入是招牌，但用过之后感觉其标准的结构，靠谱的官方包才是其优势所在(ts也有相当的帮助)，但与之对应的是规范太过复杂。")]),s._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[s._v("使用体验，要么写法上更加简洁，要么做了图形化之类的")])]),s._v(" "),t("p",[s._v("我自己写过一个图形化脚手架，基于express的，虽然是脚手架，但我是从nest中的一个什么crud的包中得到的思路，就是以mongoose的schem为核心去得到数据，再去给数据做借口,极度追求编写速度\n重点在类型上面，我觉得也算是个框架吧，因为使用的人必须要沿用这个想法\n可惜了，最后做的是restful的接口，然后express项目的swagger写起来也恶心，所以类别上没有贯彻到底，也就是接口并不是类型模式的，但如果用graphql，它和mongoose的类型又不是完全一致，本身用起来就复杂，还要转换，我就懒得弄了")])])}),[],!1,null,null,null);e.default=a.exports}}]);