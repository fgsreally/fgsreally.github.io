(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{546:function(v,e,_){"use strict";_.r(e);var t=_(4),n=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("我自己设计的低代码引擎大体分为这几个部分（承接上一篇")]),v._v(" "),_("h1",{attrs:{id:"状态类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态类"}},[v._v("#")]),v._v(" 状态类")]),v._v(" "),_("ol",[_("li",[v._v("一个代表全局状态的类，通过类上的方法来操作状态")]),v._v(" "),_("li",[v._v("一个代表操作状态的类，为上个类的父类")]),v._v(" "),_("li",[v._v("一个代表容器状态的类，为上个类的父类 (用组合也可以，但我觉得这里用继承问题不大)")])]),v._v(" "),_("p",[v._v("还有一些附加的状态类，比如线类")]),v._v(" "),_("h2",{attrs:{id:"渲染引擎与预设"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎与预设"}},[v._v("#")]),v._v(" 渲染引擎与预设")]),v._v(" "),_("ol",[_("li",[v._v("一个渲染引擎的类 ，内部产生 vnode")]),v._v(" "),_("li",[v._v("工具函数 本质上，就是物料库中的每个组件/物料，一定会映射一个对象 ，当渲染或其他操作时，只需要找这个对象上的方法就好。我称这个映射的过程为注册模块。一个模块最起码要有一个 render 方法(返回 vnode)，在这个方法的内部，(可能此时需要添加事件，注入样式等等需求)，通过实例化引擎类，编排该类上的方法(我叫这些方法为预设)，或者通过继承这个类，利用工具函数，增添自定义预设，再编排。\n也就是，只需要关心预设的编排，而不是 vnode 本身\n"),_("br"),v._v("\n附，如果对样式有独特的需求，比如我用了原子类 css，就是在预设中进行处理，如果需要换成行内样式，只需要换预设就好\n再附，一些操作，比如拖拽移动，可能会比较具备特殊性，假设我需要这个组件可以一部分暴露在容器外 or 必须全部在容器内部，这种需求就比较特殊，如果把拖拽这些东西写死，就不太方便了，这些特殊部分，完全可自定义放在预设这里")])]),v._v(" "),_("p",[v._v("这里指的渲染，可不单单是画布渲染，可以是预览环境的渲染，可以是真实环境(生产环境)的渲染，也可以是物料库时预览的渲染，甚至可以是从物料库拖拽到画布过程中的渲染。(只需要在注册模块时多加个 preview 方法 render、drag 方法等等)只要是返回 vnode 就行")]),v._v(" "),_("p",[v._v("三 代码引擎与预设\n和上面一样，但它是针对代码而不是渲染，同样通过工具函数以及预设去操作")]),v._v(" "),_("p",[v._v("这两的本质都是对 block(node) 操作变成 vnode/code")]),v._v(" "),_("p",[v._v("四一些 helper 函数与组件")]),v._v(" "),_("p",[v._v("引擎与预设并不能解决全部问题！ 比如组件在拖拽进入渲染区之前，也就是还没渲染时，此时渲染引擎上的预设还没作用，此时仍需要一些基本的工具函数")]),v._v(" "),_("p",[v._v("比较通用的工具类组件我放在另一个包里了，先不提")])])}),[],!1,null,null,null);e.default=n.exports}}]);